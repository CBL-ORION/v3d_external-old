// q_skeletonbased_warp_sub2tar.h
// by Lei Qu
// 2009-11-11

#ifndef __Q_SKELETONBASED_WARP_SUB2TAR_H__
#define __Q_SKELETONBASED_WARP_SUB2TAR_H__

#include <stdio.h>
#include <vector>
using namespace std;

#define WANT_STREAM
#include "../jba/newmat11/newmatap.h"
#include "../jba/newmat11/newmatio.h"

#include "../basic_c_fun/stackutil.h"
#include "../basic_c_fun/basic_surf_objs.h"
#include "../worm_straighten_c/spline_cubic.h"
#include "../worm_straighten_c/bdb_minus.h"

class Coord2D64F_SL
{
public:
	double x,y;
	Coord2D64F_SL(double x0,double y0) {x=x0;y=y0;}
	Coord2D64F_SL() {x=y=0.0;}
};

class DisplaceFieldF3D
{
public:
    double b_transform;

	double sx, sy, sz; //shift of x,y,z
	DisplaceFieldF3D() {sx=sy=sz=0; b_transform=0;}
	void scale(double dfactor) {sx*=dfactor;sy*=dfactor;sz*=dfactor;}
	void resetToDefault()
	{
	  sx  = 0; sy  = 0; sz  = 0;
	  b_transform=0;
	}
	bool copy(DisplaceFieldF3D *wp)
	{
	  if (!wp) return false;
	  sx  = wp->sx;  sy  = wp->sy;  sz  = wp->sz;
	  b_transform = wp->b_transform;
	  return true;
	}
	bool copy(DisplaceFieldF3D &wp)
	{
	  sx  = wp.sx;  sy  = wp.sy;  sz  = wp.sz;
	  b_transform = wp.b_transform;
	  return true;
	}

};

//warp subject image to target image based on the given principal skeletons
//output sub2tar image has same as target image
//
//Processing flow:
//(1). resize subject image to the same size as target
//(2). resize the subject principal skeleton accoridingly
//(3). staighten every branches of subject and target image respectively (for mask region and mapping index, used to define control points)
//(4). define the control points for subject and target image
//(5). compute subject to target TPS warping displace field
//(6). warp the subject image to target image based on the given displace field
//
//Parameters:
//p_img_tar,sz_img_tar:			input target image pointer and size array pointer [width, height, z, channel]
//p_img_sub,sz_img_sub:			input subject image pointer and size array pointer [width, height, z, channel]
//vec_ql_branchmarker_tar/sub:	input 2D array that contain skeleton branches along with their control points index
//d_ctlpt2node_ratio_alongbranch:input ratio of number of anchor point to control point along branch
//l_ctrlpt_perslice:			input number of control point along each slice
//l_slice_width:				input width of straightened area
//p_img_sub2tar:				output subject to target warped image
//vec_cpt_tar/sub				output target and subject control points for TPS interpolation
//
bool q_skeletonbased_sub2tar(
		const unsigned char *p_img_tar,const long *sz_img_tar,
		const unsigned char *p_img_sub,const long *sz_img_sub,
		const vector< QList<ImageMarker> > &vec_ql_branchcpt_tar,const vector< QList<ImageMarker> > &vec_ql_branchcpt_sub,
		const long l_anchor2cpt_ratio_alongbranch,const long l_anchor_perslice,const long l_slice_width,
		unsigned char *&p_img_sub2tar,
		vector<Coord2D64F_SL> &vec_anchor_tar,vector<Coord2D64F_SL> &vec_anchor_sub);


//resize the input image to the given size
//for XY plane, we use nearest interpolation
//for Z plane, we simply crop or replicate the last several slices
bool q_resize_image(
		const unsigned char *p_img_input,const long sz_img_input[4],
		const long sz_img_output[4],
		unsigned char *&p_img_output);

//cubic_spline interpolate the given curve, and then straighten the smooth curve with its neighbor to a rectangular
//the horizental central line of rectangular corresponding to the cubic_spline interpolated curve (same length)
bool q_curve_smoothstraighten(
		const unsigned char *p_inputimg,const long *sz_inputimg,
		const QList<ImageMarker> &ql_marker,const long l_width,
		unsigned char *&p_strimg,long *&sz_strimg,
		vector<Coord2D64F_SL> &vec_centralcurve,
		vector< vector<Coord2D64F_SL> > &vec_index_str2ori,vector< vector<Coord2D64F_SL> > &vec_index_ori2str);
//straight the neighbor region along the given cubic-spline interpolated curve to rectangular and return the dual directional mapping index
bool q_bcurve_straighten2rect(
		const unsigned char *p_inputimg,const long *sz_inputimg,
		const double *pos_curve_x,const double *pos_curve_y,const double *alpha_curve,const long length_curve,
		const long l_width,
		unsigned char *&p_strimg, long *&sz_strimg,
		vector< vector<Coord2D64F_SL> > &vec_index_str2ori,vector< vector<Coord2D64F_SL> > &vec_index_ori2str);


//find anchor points in target and subject image (these anchor points will be used to do TPS warping)
//the output anchor points are part of candidate anchor points generated by q_candidatecontrolpoint_definition_*evendis()
//the invalid candidate points judgement criterias are:
// (1).candidate anchor points which lie within the overlapped mask region of subject or target image but not on skeleton
// (2).candidate anchor points which do not lie within the subject or target image region
bool q_anchorpoint_definition_evendis(
		const vector<long> vec_nctlpt_alongbranch,const vector<long> vec_nctlpt_perslice,
		const vector< vector< vector<Coord2D64F_SL> > > &vecvec_index_str2ori_branch_tar,const vector< vector< vector<Coord2D64F_SL> > > &vecvec_index_ori2str_branch_tar,
		const vector< vector< vector<Coord2D64F_SL> > > &vecvec_index_str2ori_branch_sub,const vector< vector< vector<Coord2D64F_SL> > > &vecvec_index_ori2str_branch_sub,
		vector<Coord2D64F_SL> &vec_controlpoint_tar,vector<Coord2D64F_SL> &vec_controlpoint_sub);
bool q_anchorpoint_definition_unevendis(
		const vector< QList<ImageMarker> > &vec_ql_branchcpt_tar,const vector< QList<ImageMarker> > &vec_ql_branchcpt_sub,
		const long l_anchor2cpt_ratio_alongbranch,const long l_anchor_perslice,
		const vector< vector< vector<Coord2D64F_SL> > > &vecvec_index_str2ori_branch_tar,const vector< vector< vector<Coord2D64F_SL> > > &vecvec_index_ori2str_branch_tar,
		const vector< vector< vector<Coord2D64F_SL> > > &vecvec_index_str2ori_branch_sub,const vector< vector< vector<Coord2D64F_SL> > > &vecvec_index_ori2str_branch_sub,
		vector<Coord2D64F_SL> &vec_anchorpoint_tar,vector<Coord2D64F_SL> &vec_anchorpoint_sub);
//find all the candidate control points (if a control point do not lies within image, the coordinate is [-1,-1])
//find given number of control points along the central line of each branch evenly
bool q_candidateanchorpoint_definition_evendis(
		const vector< vector< vector<Coord2D64F_SL> > > vecvec_index_str2ori_branch,
		const vector<long> vec_nctlpt_alongbranch,const vector<long> vec_nctlpt_perslice,
		vector<Coord2D64F_SL> &vec_controlpoint);
//find anchor points along the smoothed branches unevenly, according to the position of control points
// e.g. take the middle point of two control points if l_ctlpt2node_ratio_alongbranch=2
bool q_candidateanchorpoint_definition_unevendis(
		const vector< QList<ImageMarker> > &vec_ql_branchcpt,
		const vector< vector< vector<Coord2D64F_SL> > > vecvec_index_str2ori_branch,const vector< vector< vector<Coord2D64F_SL> > > vecvec_index_ori2str_branch,
		const long l_anchor2cpt_ratio_alongbranch,const long l_anchor_perslice,
		vector<Coord2D64F_SL> &vec_anchorpoint);



//compute the tar2sub 2d TPS displace field based on the given subject and target control points
//note: not sub2tar in here, since we use inverse project to warp subject image to target image latter
bool q_compute_tps_df_tar2sub_2d(
		const vector <Coord2D64F_SL> &pos_controlpoint_sub,const vector <Coord2D64F_SL> &pos_controlpoint_tar,
		const long df_width,const long df_height,
		Vol3DSimple<DisplaceFieldF3D> *&df_tar2sub);

//compute sub2tar tps warp parameters based on given subject and target control points
//tps_para_wa=[w;a]
bool q_compute_tps_paras_2d(
		const vector <Coord2D64F_SL> &pos_controlpoint_sub,const vector <Coord2D64F_SL> &pos_controlpoint_tar,
		Matrix &wa);
//compute the displace field based on the given tps parameters
//sub+df_sub2tar[sub]=tar (if the input wa is paras of sub2tar)
bool q_compute_df_from_tpspara_2d(
		const Matrix &wa_sub2tar,const vector <Coord2D64F_SL> &vec_marker_sub,
		const long df_width,const long df_height,
		Vol3DSimple<DisplaceFieldF3D> *&df_sub2tar);
//compute the sub2tar warped postion for give subject point based on given sub2tar tps warping parameters
bool q_compute_ptwarped_from_tpspara_2d(
		const Coord2D64F_SL &pt_sub,const vector <Coord2D64F_SL> &vec_ctlpt_sub,const Matrix &wa_sub2tar,
		Coord2D64F_SL &pt_sub2tar);

//warp subject image to target image based on 2d tar2sub displace field
bool q_warp_sub2tar_baseon_df_tar2sub(
		const unsigned char *p_img_sub,const long *sz_img_sub,
		const Vol3DSimple<DisplaceFieldF3D> *df_tar2sub,
		unsigned char *&p_img_sub2tar);



//save the points position to marker file
bool q_points_save2markerfile(
		const vector<Coord2D64F_SL> &pos_pointset,
		const char *filename_marker);

//save the input larval image with head and butt straighten area mask overlaid
bool q_saveimg_strmask_overlaid(
		const unsigned char *p_inputimg,const long sz_inputimg[4],
		const vector< vector< vector<Coord2D64F_SL> > > vecvecvec_index_ori2str_branches,
		const char *filename_outputimg);

//first: compute the df_sub2tar based on the input df_tar2sub (note: we did not interpolate the df_sub2tar due to lazy)
//then : warp central line of subject image to target use df_sub2tar (note: not all subpos can find df in df_sub2tar, we only keep the valid one)
//last:  save the warped central line to swc file
//the warped central line should be very similar to the central line of target image
//the warped central line do not have the same points as input, since we did not interpolate the df_sub2tar
//we simply output the points happen to be in the displace field of tar2sub
bool q_save_warpedskeleton2swcfile_1(
		const vector<Coord2D64F_SL> &vec_centralline_head_tar,const vector<Coord2D64F_SL> &vec_centralline_tail_tar,
		const vector<Coord2D64F_SL> &vec_centralline_head_sub,const vector<Coord2D64F_SL> &vec_centralline_tail_sub,
		Vol3DSimple<DisplaceFieldF3D> *df_tar2sub,
		const char *filename_outputswc);
//first: compute the sub2tar tps warp paras based on the input sub and tar control points
//then:  warp central line of subject image to target use sub2tar tps pars
//last:  save warped central line to swc file
bool q_save_warpedskeleton2swcfile_2(
		const vector <Coord2D64F_SL> &pos_controlpoint_sub,const vector <Coord2D64F_SL> &pos_controlpoint_tar,
		const vector<Coord2D64F_SL> &vec_centralline_head_sub,const vector<Coord2D64F_SL> &vec_centralline_tail_sub,
		const char *filename_outputswc);

#endif

